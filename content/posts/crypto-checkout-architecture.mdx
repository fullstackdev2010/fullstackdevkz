---
title: Crypto Checkout Architecture — ETH & TRX, QR, and Auto-Confirmation
date: "2025-10-31"
excerpt: "A practical architecture for ETH/TRX checkout: addresses + QR, testnets for dev, auto-confirm, receipts, and explorer verification."
tags: [crypto, payments, wagmi, tron, web3]
---

This post outlines a pragmatic crypto checkout for digital goods. We support **Ethereum (ETH/ERC-20)** and **TRON (TRX/TRC-20)**, with **QR codes**, **testnets** for development, and **auto-confirmation** for a smooth UX.

## Goals

- Clear payment UX (amount, address, memo if needed, currency)
- Auto-detect confirmations and show a human-readable receipt
- Keep the UI responsive; never block on chain I/O
- Make dev painless (switch to testnets instantly)

## Client flow (React)

- Show a checkout modal with **selected chain**, **asset**, **amount**, and a QR code.
- If user connects a wallet (e.g. wagmi), we deep-link and prefill the tx.
- We poll/subscribe for confirmations; we surface **pending → confirmed**.

```tsx
// pseudo: usePayment
type Chain = 'eth' | 'tron';
export function usePayment() {
  const [status, setStatus] = useState<'idle'|'pending'|'confirmed'|'failed'>('idle');
  const [txHash, setTxHash] = useState<string | null>(null);

  async function start({ chain, to, amount, asset }: { chain: Chain; to: string; amount: string; asset: string; }) {
    setStatus('pending');
    // render QR like ethereum:0x.. or tron:TX...?amount=
    // if wallet connected (wagmi), sendTransaction({ to, value/erc20, chainId })
  }

  async function watch({ chain, hash }: { chain: Chain; hash: string; }) {
    // poll provider or subscribe via backend websocket → setStatus('confirmed') on success
    setTxHash(hash);
  }

  return { status, txHash, start, watch };
}
```

## Addressing & amounts

- **ETH / ERC-20**: EIP-681 URIs (`ethereum:pay-0xAddress@chainId/transfer?value=...`)
- **TRX / TRC-20**: TronLink deeplinks or plain address + memo where applicable
- Always show fiat approximation in UI for clarity

## Auto-confirmation

**ETH path (wagmi):**
- `publicClient.waitForTransactionReceipt({ hash })` for finality targets (N blocks)
- Retry with backoff; show a “still confirming” badge

**TRON path:**
- Use TronGrid/API or a backend watcher to confirm `txID` and token transfer logs

## Backend responsibilities

- Create **payment intents** with: `id`, `chain`, `asset`, `expectedAmount`, `toAddress`, `expiresAt`
- Verify incoming tx against intent (amount ≥ expected, correct asset & address)
- **Idempotent** confirm endpoint: multiple client calls are safe
- Persist a **receipt** (JSON), sign it server-side, return to client

```py
# FastAPI pseudo
@app.post('/pay/intent')
def create_intent(payload: IntentIn):
    intent = save_intent(payload)  # id, toAddress, expiresAt
    return intent

@app.post('/pay/confirm')
def confirm(tx: TxIn):
    ok = verify_onchain(tx)        # chain-specific verification
    if ok: receipt = save_receipt(tx.intentId, tx.hash)
    return { 'ok': ok, 'receipt': receipt }
```

## Receipts & explorer links

- Show a human-readable receipt with: **item(s)**, **amount**, **chain**, **asset**, **tx hash**, **timestamp**, **status**
- Include **explorer link** (Etherscan / TronScan) and raw hash for audits
- Email/printable PDF optional; we also store a signed JSON blob

## Testnets

- ETH: **Sepolia/Holesky**
- TRON: **Nile/Shasta** (as available)
- Toggle via a single environment var and render **Testnet** badges in UI

## Security & ops

- Enforce minimal **confirmations** per chain/asset
- Watch for **under-payments** and **replays** (intent tie-in)
- Add alerting for stuck or failed intents

---

This setup has been battle-tested in our prototypes and is easy to extend with more assets later. In the case study pages we include the receipts UX and explorer verification as part of the success criteria.
